package de.envite.proa.repository.processmodel;

import de.envite.proa.entities.process.EventType;
import de.envite.proa.entities.process.RelatedProcessModel;
import de.envite.proa.repository.project.ProjectDao;
import de.envite.proa.repository.tables.ProcessEventTable;
import de.envite.proa.repository.tables.ProcessModelTable;
import de.envite.proa.repository.tables.ProjectTable;
import de.envite.proa.repository.tables.RelatedProcessModelTable;
import de.envite.proa.usecases.RelatedProcessModelRepository;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.persistence.NoResultException;

import java.util.*;

@ApplicationScoped
public class RelatedProcessModelRepositoryImpl implements RelatedProcessModelRepository {

    private final ProjectDao projectDao;
    private final ProcessModelDao processModelDao;
    private final RelatedProcessModelDao relatedProcessModelDao;

    @Inject
    public RelatedProcessModelRepositoryImpl(ProjectDao projectDao, ProcessModelDao processModelDao, RelatedProcessModelDao relatedProcessModelDao) {
        this.projectDao = projectDao;
        this.processModelDao = processModelDao;
        this.relatedProcessModelDao = relatedProcessModelDao;
    }

    @Override
    public void calculateAndSaveRelatedProcessModels(ProjectTable projectTable) {
        List<ProcessModelTable> allModels = getAllRootProcessModels(projectTable);

        for (ProcessModelTable model : allModels) {
            if (!hasValidStartAndEndEvents(model)) {
                return;
            }

            List<ProcessModelTable> matchingModels = findMatchingModels(model, allModels);

            if (matchingModels.size() <= 1) {
                processSingleModel(model);
                return;
            }

            updateModelLevelsAndSave(model, matchingModels);
        }
    }

    private List<ProcessModelTable> getAllRootProcessModels(ProjectTable projectTable) {
        return processModelDao.getProcessModels(projectTable, null)
                .stream()
                .filter(model -> model.getParents() == null || model.getParents().isEmpty())
                .toList();
    }

    private boolean hasValidStartAndEndEvents(ProcessModelTable model) {
        return !getStartEventNameFromBpmn(model).isEmpty() && !getEndEventNameFromBpmn(model).isEmpty();
    }

    private List<ProcessModelTable> findMatchingModels(ProcessModelTable model, List<ProcessModelTable> allModels) {
        List<String> startEventName = getStartEventNameFromBpmn(model);
        List<String> endEventName = getEndEventNameFromBpmn(model);

        return allModels.stream()
                .filter(otherModel -> {
                    List<String> otherStartEventNames = getStartEventNameFromBpmn(otherModel);
                    List<String> otherEndEventNames = getEndEventNameFromBpmn(otherModel);
                    return startEventName.stream().anyMatch(otherStartEventNames::contains) &&
                            endEventName.stream().anyMatch(otherEndEventNames::contains);
                })
                .sorted(Comparator.comparingInt(otherModel -> otherModel.getBpmnXml().length))
                .toList();
    }

    private void processSingleModel(ProcessModelTable model) {
        model.setLevel(model.getLevel() != null ? model.getLevel() : null);
        processModelDao.merge(model);
    }

    private void updateModelLevelsAndSave(ProcessModelTable model, List<ProcessModelTable> matchingModels) {
        int rootLevel = 1;
        List<RelatedProcessModelTable> relatedProcessModels = new ArrayList<>();
        List<RelatedProcessModelTable> manuallyAddedRelations = relatedProcessModelDao.getManuallyAddedRelations(model);

        for (int i = 0; i < matchingModels.size(); i++) {
            ProcessModelTable otherModel = matchingModels.get(i);
            int level = rootLevel + i;

            if (otherModel.equals(model)) {
                model.setLevel(level);
                processModelDao.merge(model);
            } else {
                relatedProcessModels.add(createRelatedModel(model, otherModel, level));
            }
        }

        relatedProcessModelDao.deleteAutoGeneratedByProcessModel(model);

        relatedProcessModels.addAll(manuallyAddedRelations);
        relatedProcessModels.forEach(relatedProcessModelDao::merge);
    }

    private RelatedProcessModelTable createRelatedModel(ProcessModelTable model, ProcessModelTable otherModel, int level) {
        RelatedProcessModelTable relatedProcessModel = new RelatedProcessModelTable();
        relatedProcessModel.setProcessModel(model);
        relatedProcessModel.setRelatedProcessModelId(otherModel.getId());
        relatedProcessModel.setProcessName(otherModel.getName());
        relatedProcessModel.setLevel(level);
        relatedProcessModel.setManuallyAdded(false);
        return relatedProcessModel;
    }

    @Override
    public void addRelatedProcessModel(Long projectId, Long id, List<Long> relatedProcessModelIds) {
        ProjectTable projectTable = projectDao.findById(projectId);

        if (projectTable == null) {
            throw new NoResultException("Project not found.");
        }

        List<ProcessModelTable> allModels = processModelDao.getProcessModelsByIds(projectTable, relatedProcessModelIds);
        ProcessModelTable processModel = processModelDao.find(id);

        if (allModels.isEmpty() || processModel == null) {
            throw new NoResultException("Process model not found.");
        }

        if (!processModel.getParents().isEmpty()) {
            throw new IllegalArgumentException("Process model with related parents cannot be added to related process models.");
        }

        allModels.add(processModel);
        allModels = allModels.stream()
                .sorted(Comparator.comparingInt(model -> model.getBpmnXml().length))
                .toList();

        Map<Long, Integer> modelLevels = new HashMap<>();
        int rootLevel = 1;

        for (int i = 0; i < allModels.size(); i++) {
            ProcessModelTable model = allModels.get(i);
            int level = rootLevel + i;
            model.setLevel(level);
            modelLevels.put(model.getId(), level);
            processModelDao.merge(model);
        }

        for (ProcessModelTable model : allModels) {
            List<RelatedProcessModelTable> relatedProcessModels = new ArrayList<>();

            for (ProcessModelTable otherModel : allModels) {
                if (!otherModel.equals(model)) {
                    boolean wasManuallyAdded = relatedProcessModelDao.existsManuallyAddedRelation(model, otherModel);
                    boolean isManuallyAdded = wasManuallyAdded || model.equals(processModel) || otherModel.equals(processModel);

                    RelatedProcessModelTable relatedProcessModel = new RelatedProcessModelTable();
                    relatedProcessModel.setProcessModel(model);
                    relatedProcessModel.setRelatedProcessModelId(otherModel.getId());
                    relatedProcessModel.setProcessName(otherModel.getName());
                    relatedProcessModel.setLevel(modelLevels.get(otherModel.getId()));
                    relatedProcessModel.setManuallyAdded(isManuallyAdded);
                    relatedProcessModels.add(relatedProcessModel);
                }
            }

            relatedProcessModelDao.deleteByProcessModel(model);
            relatedProcessModels.forEach(relatedProcessModelDao::merge);
        }
    }

    private List<String> getStartEventNameFromBpmn(ProcessModelTable model) {
        if (model != null && !model.getEvents().isEmpty()) {
            return model.getEvents().stream()
                    .filter(event -> event.getEventType() == EventType.START)
                    .map(ProcessEventTable::getLabel)
                    .filter(label -> label != null && !label.isEmpty())
                    .toList();
        }
        return Collections.emptyList();
    }

    private List<String> getEndEventNameFromBpmn(ProcessModelTable model) {
        if (model != null && !model.getEvents().isEmpty()) {
            return model.getEvents().stream()
                    .filter(event -> event.getEventType() == EventType.END)
                    .map(ProcessEventTable::getLabel)
                    .filter(label -> label != null && !label.isEmpty())
                    .toList();
        }
        return Collections.emptyList();
    }

    @Override
    public RelatedProcessModel mapToRelatedProcessModel(RelatedProcessModelTable relatedProcessModelTable) {
        RelatedProcessModel relatedProcessModel = new RelatedProcessModel();
        relatedProcessModel.setRelatedProcessModelId(relatedProcessModelTable.getRelatedProcessModelId());
        relatedProcessModel.setProcessName(relatedProcessModelTable.getProcessName());
        relatedProcessModel.setLevel(relatedProcessModelTable.getLevel());
        relatedProcessModel.setManuallyAdded(relatedProcessModelTable.isManuallyAdded());

        return relatedProcessModel;
    }
}
